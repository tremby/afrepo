#!/usr/bin/env php
<?php

/**
 * Bart Nagel <bjn@ecs.soton.ac.uk>
 */

require dirname(dirname(__FILE__)) . "/setup.php";

// sort out commandline options
require dirname(dirname(__FILE__)) . "/lib/clioptions/CliOptions.class.php";
$opts = new CliOptions();
$opts->add(null, "help");
$opts->add(null, "classifier", CliOption::TYPE_MULTIPLEVALUE, null, "Use the given classifier rather than using all classifiers. Can be used more than once to pick multiple classifiers.");
$opts->add(null, "output-metadata", CliOption::TYPE_SWITCH, null, "Output metadata as it is found");
$opts->add(null, "canonical-paths", CliOption::TYPE_SWITCH, null, "Output canonical paths rather than file IDs");
$opts->add(null, "force", CliOption::TYPE_SWITCH, null, "Skip any cached files and run the classifier anew");
$opts->add(null, "force-missing", CliOption::TYPE_SWITCH, null, "Like --force but only for those missing MBIDs");
$opts->add(null, "id", CliOption::TYPE_SWITCH, null, "Interpret arguments as IDs rather than paths");
$opts->add(null, "threads", CliOption::TYPE_VALUE, "1", "Number of threads to run (default 1)");
$opts->add("l", "list", CliOption::TYPE_SWITCH, null, "List available classifiers and exit");
$opts->add("v", "verbose", CliOption::TYPE_SWITCH, null, "Verbose threads");

function usage($code = 255) {
	global $opts;
	$stream = $code == 0 ? STDOUT : STDERR;
	fwrite($stream, "Usage: " . basename($_SERVER["SCRIPT_NAME"]) . " [options] [<filepath> [...]]\n");
	fwrite($stream, "With no file paths listed all files in the repository will be classified.\n");
	fwrite($stream, "If one or more paths is listed the --output-metadata option is implicit.\n");
	fwrite($stream, "If there were errors classifying any file, exit with an error status (1), otherwise success.\n");
	fwrite($stream, $opts->listopts());
	exit($code);
}

try {
	$options = $opts->getopts();
} catch (CliOptionException $e) {
	fwrite(STDERR, $e->getMessage() . "\n\n");
	usage();
}

// help message if requested
if ($options["help"]) {
	usage(0);
}

// classifier list if requested
if ($options["list"]) {
	echo "Available classifiers:\n\n";
	foreach (allclassifiers() as $classname => $classifier)
		echo "$classname\n\t" . $classifier->getName() . "\n\n\t" . wordwrap($classifier->getDescription(), 70, "\n\t") . "\n\n";
	exit;
}

// number of threads
if (!is_numeric($options["threads"])) {
	fwrite(STDERR, "expected a positive integer as a parameter to the --threads option\n\n");
	usage();
} else {
	$options["threads"] = intVal($options["threads"]);
	if ($options["threads"] < 1) {
		fwrite(STDERR, "expected a positive integer as a parameter to the --threads option\n\n");
		usage();
	}
}

// get list of classifiers to use
if (is_array($options["classifier"])) {
	$classifiers = array();
	foreach ($options["classifier"] as $classname) {
		$classifier = getclassifier($classname);
		if ($classifier === false) {
			fwrite(STDERR, "classifier '" . $options["classifier"] . "' doesn't exist\n");
			exit(255);
		}
		$classifiers[] = $classifier;
	}
} else
	$classifiers = allclassifiers();

// get list of files to classify
$repo = new AFRepo();
if (empty($options["_"])) {
	$options["id"] = false;
	$options["_"] = array_keys($repo->getAllFiles());
} else
	$options["output-metadata"] = true;

// fork required number of times
$pids = array();
$thread = false;
$errorfiles = array();
for ($i = 0; $i < $options["threads"]; $i++) {
	$errorfile = tempnam(sys_get_temp_dir(), "t$i.");
	$errorfiles[] = $errorfile;
	$pid = pcntl_fork();
	if ($pid == -1) {
		fwrite(STDERR, "could not fork\n");
		exit(8);
	}
	if ($pid) {
		// parent
		$pids[] = $pid;
	} else {
		// child
		$thread = $i;
		break;
	}
}

if ($thread === false) {
	// parent -- wait for children to finish, then exit
	$errors = false;
	foreach ($pids as $pid) {
		pcntl_waitpid($pid, $status);
		if (pcntl_wexitstatus($status) > 0)
			$errors = true;
	}
	echo "all threads are finished\n";
	if ($errors) {
		fwrite(STDERR, "at least one child exited with an error status\n");
		// load error files
		$errorids = array();
		foreach ($errorfiles as $errorfile) {
			if (file_exists($errorfile)) {
				if (filesize($errorfile))
					$errorids = array_merge($errorids, unserialize(file_get_contents($errorfile)));
				unlink($errorfile);
			}
		}
		$errorids = array_unique($errorids);
		fwrite(STDERR, "errors involved the audio files with IDs\n");
		foreach ($errorids as $errorid)
			fwrite(STDERR, $errorid . "\n");
		exit(1);
	}
	exit;
}

// loop through files
$fcount = 0;
$ftotal = count($options["_"]);
$ftotalchars = strlen((string) $ftotal);
$errorids = array();
foreach ($options["_"] as $file) {
	$fcount++;
	if ($options["id"])
		$id = $file;
	else
		$id = $repo->filePathToId($file);

	// loop through classifiers
	foreach ($classifiers as $classifier) {
		// skip if we can't get a lock
		if (!$classifier->lock($id)) {
			if ($options["verbose"])
				echo "thread $thread: skipping file $id since we can't get a lock\n";
			continue;
		}

		// position
		$pos = "[" . sprintf("%0{$ftotalchars}d", $fcount) . "/" . $ftotal . "]";

		if ($options["verbose"])
			echo "thread $thread: working on file $id $pos, classifier " . get_class($classifier) . "\n";

		$out = $pos . "\t";
		if ($options["verbose"])
			$out .= "t$thread\t";
		$out .= ($options["canonical-paths"] ? $repo->idToCanonicalPath($id) : $id) . "\t";
		$out .= get_class($classifier) . "\t";

		if ($options["force-missing"] && $classifier->hasMBID($id)) {
			$out .= $classifier->getMBID($id);
			echo $out . "\n";
			$classifier->unlock($id);
			continue;
		}

		$metadata = $classifier->classify($id, $options["force-missing"] || $options["force"]);
		if ($metadata === false) {
			$errorids[] = $id;
			$out .= str_pad("error", 36, "-", STR_PAD_BOTH);
		}
		else if ($options["output-metadata"])
			$out .= print_r($metadata, true);
		else {
			$mbid = $classifier->getMBID($id);
			if (is_null($mbid))
				$out .= str_pad("MBID not found", 36, "-", STR_PAD_BOTH);
			else
				$out .= $mbid;
		}

		echo $out . "\n";
		$classifier->unlock($id);
	}
}
if ($options["verbose"])
	echo "thread $thread: finished looping through files\n";

if (count($errorids)) {
	file_put_contents($errorfile, serialize(array_unique($errorids)));
	exit(1);
}

exit;

?>
